var l=class o{constructor(e=[],t=[],s=!1){this.lengths=e??[],this.coords=t??[],this.hasIndeterminateRingOrder=s}static fromRect(e){let[t,s,r,n]=e,h=r-t,i=n-s;return new o([5],[t,s,h,0,0,i,-h,0,0,-i])}get isPoint(){return this.lengths.length===0}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((e,t)=>e+t)}forEachVertex(e){let t=0;this.lengths.length||e(this.coords[0],this.coords[1]);for(let s=0;s<this.lengths.length;s++){let r=this.lengths[s];for(let n=0;n<r;n++)e(this.coords[2*(n+t)],this.coords[2*(n+t)+1]);t+=r}}deltaDecode(){let e=this.clone(),{coords:t,lengths:s}=e,r=0;for(let n of s){for(let h=1;h<n;h++)t[2*(r+h)]+=t[2*(r+h)-2],t[2*(r+h)+1]+=t[2*(r+h)-1];r+=n}return e}clone(e){if(this.lengths.length===0)return new o([],[this.coords[0],this.coords[1]]);let t=(this.lengths.length===0?1:this.lengths.reduce((r,n)=>r+n))*2,s=this.coords.slice(0,t);return e?(e.set(s),new o(this.lengths,e,this.hasIndeterminateRingOrder)):new o(Array.from(this.lengths),Array.from(s),this.hasIndeterminateRingOrder)}};export{l as a};
