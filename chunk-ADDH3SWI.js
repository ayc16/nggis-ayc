import{c as h}from"./chunk-GJBALZEB.js";import{e as r,h as a,r as f,v as c}from"./chunk-ZAQLF7TN.js";import{r as F}from"./chunk-HQMV3KQV.js";import{A,C as R,j as o}from"./chunk-CRMMDK2Z.js";import{h as E}from"./chunk-EAH6BNBL.js";var b=()=>F.getLogger("esri.views.webgl.BufferObject");var l=class n{static createIndex(e,t,s){return new n(e,r.ELEMENT_ARRAY_BUFFER,t,s)}static createVertex(e,t,s){return new n(e,r.ARRAY_BUFFER,t,s)}static createUniform(e,t,s){return new n(e,r.UNIFORM_BUFFER,t,s)}static createPixelPack(e,t=f.STREAM_READ,s){let i=new n(e,r.PIXEL_PACK_BUFFER,t);return s&&i.setSize(s),i}static createPixelUnpack(e,t=f.STREAM_DRAW,s){return new n(e,r.PIXEL_UNPACK_BUFFER,t,s)}static createTransformFeedback(e,t=f.STATIC_DRAW,s){let i=new n(e,r.TRANSFORM_FEEDBACK_BUFFER,t);return i.setSize(s),i}constructor(e,t,s,i){this._context=e,this.bufferType=t,this.usage=s,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(c.BufferObject,this),this._glName=this._context.gl.createBuffer(),h(this._context.gl),i&&this.setData(i)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get usedMemory(){return this.bufferType===r.ELEMENT_ARRAY_BUFFER?this._indexType===a.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===r.ELEMENT_ARRAY_BUFFER||this.bufferType===r.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(c.BufferObject,this),this._context=null):this._glName&&b().warn("Leaked WebGL buffer object")}setSize(e,t=null){if(this.bufferType===r.ELEMENT_ARRAY_BUFFER&&t!=null)switch(this._indexType=t,t){case a.UNSIGNED_SHORT:e*=2;break;case a.UNSIGNED_INT:e*=4}this._setBufferData(e)}setData(e){if(!e)return;let t=e.byteLength;this.bufferType===r.ELEMENT_ARRAY_BUFFER&&(A(e)&&(t/=2,this._indexType=a.UNSIGNED_SHORT),R(e)&&(t/=4,this._indexType=a.UNSIGNED_INT)),this._setBufferData(t,e)}_setBufferData(e,t=null){this._size=e;let s=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let i=this._context.gl;t!=null?i.bufferData(this.bufferType,t,this.usage):i.bufferData(this.bufferType,e,this.usage),h(i),this._isVAOAware&&this._context.bindVAO(s)}setSubData(e,t,s,i){if(!e)return;let u=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let{gl:_}=this._context;_.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,e,s,i-s),h(_),this._isVAOAware&&this._context.bindVAO(u)}getSubData(e,t=0,s,i){if(s<0||i<0)return;let u=B(e)?e.BYTES_PER_ELEMENT:1;if(u*((s??0)+(i??0))>e.byteLength)return;t+u*(i??0)>this.usedMemory&&b().warn("Potential problem getting subdata: requested data exceeds buffer size!");let _=this._context.gl;this.bufferType===r.TRANSFORM_FEEDBACK_BUFFER?(this._context.bindBuffer(this,r.TRANSFORM_FEEDBACK_BUFFER),_.getBufferSubData(r.TRANSFORM_FEEDBACK_BUFFER,t,e,s,i),this._context.unbindBuffer(r.TRANSFORM_FEEDBACK_BUFFER)):(this._context.bindBuffer(this,r.COPY_READ_BUFFER),_.getBufferSubData(r.COPY_READ_BUFFER,t,e,s,i),this._context.unbindBuffer(r.COPY_READ_BUFFER))}getSubDataAsync(e,t=0,s,i){return E(this,null,function*(){yield this._context.clientWaitAsync(),this.getSubData(e,t,s,i)})}};function B(n){return o(n)}export{l as a};
