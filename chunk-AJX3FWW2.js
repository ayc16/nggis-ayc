import{a as n}from"./chunk-BTFKH6KF.js";import{f as ne}from"./chunk-7SVLZCA4.js";import{f as se,o as ie}from"./chunk-DYVXH2D6.js";import{a as ee,p as T,q as oe}from"./chunk-MRVR6F6G.js";import{i as te,l as L,m as re}from"./chunk-WXQQZY3K.js";import{v as ae}from"./chunk-OZF6BMOL.js";import{a as _}from"./chunk-GJP6PTKT.js";import{h as Y,i as $,l as I}from"./chunk-SA4OMQAD.js";import{b as X}from"./chunk-24BLFS5R.js";import{$ as H,A as j,I as K,R as B,da as J,ea as N,k as F,ka as Q}from"./chunk-JDDD6VJ4.js";import{L as P}from"./chunk-AUTL5LCV.js";import{S as V}from"./chunk-KUJG22IX.js";import{a as g}from"./chunk-W3WDPWBE.js";import{b as D}from"./chunk-HQMV3KQV.js";import{g as A,q as v}from"./chunk-CRMMDK2Z.js";import{a as k}from"./chunk-EAH6BNBL.js";var q,M=q=class extends T{constructor(...r){super(...r),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(r,e){let i;if(r?.center)i=r;else{if(r?.rings)return super.normalizeCtorArgs(r,e);i={center:r}}return k(k(k({},super.normalizeCtorArgs()),i),e)}initialize(){let r=this.center,e=this.numberOfPoints;if(this.hasZ=r?.hasZ??!1,this.rings.length!==0||!r)return;let i=B(this.radius,this.radiusUnit,"meters"),o=r.spatialReference,s,t="geographic";if(o.isWebMercator?t="webMercator":((o.wkid&&F[o.wkid])!=null||(o.wkt2||o.wkt)&&Q(o.wkt2||o.wkt))&&(t="projected"),this.geodesic){let a;switch(t){case"webMercator":a=$(r);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":a=r}s=this._createGeodesicCircle(a,i,e),t==="webMercator"&&(s=Y(s))}else{let a;t==="webMercator"||t==="projected"?a=i/N(r.spatialReference):t==="geographic"&&(a=H(i,"meters",K(r.spatialReference).radius)),s=this._createPlanarCircle(r,a,e)}this.spatialReference=s.spatialReference,this.addRing(s.rings[0])}clone(){let{center:r,numberOfPoints:e,radius:i,radiusUnit:o,geodesic:s}=this;return new q({center:r?.clone(),numberOfPoints:e,radius:i,radiusUnit:o,geodesic:s})}_createGeodesicCircle(r,e,i){let o=0,s=[];for(;o<360;){let t=[0,0],a=[r.x,r.y];ne(t,a,o,e,X.WGS84),this.hasZ&&t.push(r.z),s.push(t),o+=360/i}return s.push(s[0]),new T(s)}_createPlanarCircle(r,e,i){let o=[],s=2*Math.PI/i;for(let t=0;t<i;++t){let a=s*t,c=[r.x+Math.cos(-a)*e,r.y+Math.sin(-a)*e];this.hasZ&&c.push(r.z),o.push(c)}return o.push(o[0]),new T({spatialReference:r.spatialReference,rings:[o]})}};g([P({type:I})],M.prototype,"center",void 0),g([P()],M.prototype,"geodesic",void 0),g([P()],M.prototype,"numberOfPoints",void 0),g([P()],M.prototype,"radius",void 0),g([P()],M.prototype,"radiusUnit",void 0),M=q=g([V("esri.geometry.Circle")],M);var le=M;function b(r,e){let i=new I({x:r[0],y:r[1],spatialReference:e});return r.length>2&&(i.z=r[2]),i}function Fe(r,e){return new ee({points:r,spatialReference:e})}function Ke(r,e,i){let o=new oe({paths:r,spatialReference:e});return i&&L(o),o}function G(r,e,i,o=!0){let s=D(r);s.forEach(a=>{let c=a[0],l=a[a.length-1];A(c,l)&&a.length!==1||a.push(a[0])});let t=new T({rings:s,spatialReference:e});return t.rings.forEach(a=>{te(a)||a.reverse()}),i&&L(t),o&&t.isSelfIntersecting&&j(e)&&(t=ie(t)),t}function Be(r,e,i){let o=e.mapToLocalMultiple(r),s=[],t={x:o[0].x,y:o[0].y},a={x:o[1].x,y:o[1].y},c=Math.round(a.x-t.x),l=Math.round(a.y-t.y),m=Math.max(Math.abs(c),Math.abs(l));if(i){let p={x:t.x+m,y:t.y+m},h={x:t.x-m,y:t.y-m};s.push(n(p.x,h.y),n(h.x,h.y),n(h.x,p.y),n(p.x,p.y))}else{let p={x:c>0?t.x+m:t.x-m,y:l>0?t.y+m:t.y-m};s.push(n(t.x,t.y),n(p.x,t.y),n(p.x,p.y),n(t.x,p.y))}return ce(G([s.map(p=>e.localToMap(p)).filter(v)],e.spatialReference,e.doUnnormalization,!0),s,e)}function He(r,e,i){let o=e.mapToLocalMultiple(r);if(o.length===1){let l=o[0];o=[n(l.x-48,l.y+48),n(l.x+48,l.y-48),n(l.x+48,l.y-48),n(l.x-48,l.y+48)]}let s=[],t={x:o[0].x,y:o[0].y},a={x:o[1].x,y:o[1].y};if(i){let c=Math.round(a.x-t.x),l=Math.round(a.y-t.y);s.push(n(t.x-c,t.y-l),n(a.x,t.y-l),n(a.x,a.y),n(t.x-c,a.y))}else s.push(n(t.x,t.y),n(a.x,t.y),n(a.x,a.y),n(t.x,a.y));return ce(G([s.map(c=>e.localToMap(c)).filter(v)],e.spatialReference,e.doUnnormalization,!0),s,e)}function ce(r,e,i){let o=O(e[3],e[2],i),s=O(e[1],e[2],i),t=O(e[0],e[1],i),a=O(e[0],e[3],i);return{geometry:r,midpoints:o!=null&&s!=null&&t!=null&&a!=null?{top:o,right:s,bottom:t,left:a}:null}}function O(r,e,i){z[0]=r.x,z[1]=r.y,z[2]=0,U[0]=e.x,U[1]=e.y,U[2]=0,ae(z,z,U,.5),S.x=z[0],S.y=U[1],S.z=U[2];let o=i.localToMap(S);return o!=null?b(o,i.spatialReference):null}var S=n(0,0,0),z=_(),U=_();function Je(r,e,i,o){let s=e.mapToLocalMultiple(r),t=null,a=null;if(i)t=s[0],a=s[1];else{let u=s[0],f=s[1],R=Math.round(f.x-u.x),w=Math.round(f.y-u.y),y=Math.max(Math.abs(R),Math.abs(w));t=n(R>0?u.x+y/2:u.x-y/2,w>0?u.y+y/2:u.y-y/2),a=n(Math.abs(R)>Math.abs(w)?t.x-y/2:t.x,Math.abs(R)>Math.abs(w)?t.y:t.y-y/2)}let c=e.localToMap(t),l=e.localToMap(a);if(c==null||l==null)return null;e.doUnnormalization&&re([[c,l]],e.spatialReference);let m=b(c,e.spatialReference),p=b(l,e.spatialReference),h=J(e.spatialReference),x=0;if(j(e.spatialReference))x=h*se(m,p,null);else{let u=t.x-a.x,f=t.y-a.y;x=h*Math.sqrt(u*u+f*f)*(o||1)}let C=new le({center:m,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:G(C.rings,C.spatialReference,!1),center:m,edge:p}}function Ne(r,e,i){let o=e.mapToLocalMultiple(r),s=o[0],t=o[1],a=Math.round(t.x-s.x),c=Math.round(t.y-s.y),l=n(i?s.x:s.x+a/2,i?s.y:s.y+c/2),m=i?a:a/2,p=i?c:c/2,h=60,x=[],C=2*Math.PI/h;function u(d){let pe=Math.cos(d),ue=Math.sin(d);return n(m*pe+l.x,p*ue+l.y)}for(let d=0;d<h;d++)x.push(u(d*C));x.push(x[0]);let{spatialReference:f,doUnnormalization:R}=e,w=G([x.map(d=>e.localToMap(d)).filter(v)],f,R,!1),y=e.localToMap(u(Math.PI/2)),E=e.localToMap(u(0)),W=e.localToMap(u(-Math.PI/2)),Z=e.localToMap(u(Math.PI));return{geometry:w,midpoints:y!=null&&E!=null&&W!=null&&Z!=null?{top:b(y,f),right:b(E,f),bottom:b(W,f),left:b(Z,f)}:null}}export{Fe as a,Ke as b,G as c,Be as d,He as e,Je as f,Ne as g};
